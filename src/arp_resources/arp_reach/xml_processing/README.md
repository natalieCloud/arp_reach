# xml_processing README

Hello there! This is the readme for the xml_processing package! This package is one of the many developed alongside others in order to provide `Reach` functionality to the [ar_paint](https://github.com/OSU-AIMS/augmented-reality-painting) project!

What xml_processing does is that it provides a service node that would read in the client's `Pose Array` and `Reach DB file` and parses through the database (XML) file, and returns the original `Pose Array` with a corresponding array of `reach scores`! Both of these files are currently stored in the tmp folder (which is unfortunatley not OS agnostic :(  ...yet- see [issue #13](https://github.com/natalieCloud/arp_reach/issues/13))

## Requirements to Build:

To sucessfully build this project one must have minimum [ROS 2 Humble](https://docs.ros.org/en/humble/Installation.html) installed, as well as [python3](https://www.python.org/downloads/) configs set up!

Also, the package [arp_msgs](https://github.com/natalieCloud/arp_reach/tree/main/src/arp_resources/arp_msgs) is nessesary for this package to build!

## Nodes

### [XMLToPoseArrayClient](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_reach/xml_processing/nodes/XMLToPoseArrayClient.cpp)
This class instantiates a node that handles the request from [FormatPosesFromXml.srv](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_msgs/srv/FormatPosesFromXML.srv). It first pases in a string representing the filepath of the `reach_ros` reach study results (Formatted in XMl), as well as a `PoseArray` of all the points that we wish to extract the reach results for. Then it pases these to the service which will return the original `PoseArray` as well as a corresponding array of reach scores back to the client!

### [XMLToPoseArrayService](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_reach/xml_processing/nodes/XMLToPoseArrayService.cpp)
This instantiates a node that handles the service from [FormatPosesFromXml.srv](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_msgs/srv/FormatPosesFromXML.srv). It first takes the request of the `XML` filepath and `PoseArray` from the client and then pases those off, first to the [xml_parser](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_reach/xml_processing/parsing_lib/src/xml_parser.cpp), which reads in the data from the file provided and outputs a data struct, which is then parsed by the [result_parser](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_reach/xml_processing/parsing_lib/src/result_parsing.cpp), which uses a multi-threaded parser to contruct a score array, which is then passed back to the client!

## Support Files

### [array_transform](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_reach/xml_processing/parsing_lib/src/array_transform.cpp)

This class takes in an array of size 16 generated by the xml parser and transforms the data into a `quaternion` form which can then be easily used in the client server setup!

**public**:

*getQuaternion(poseArray)*:
- This function inputs an array of pose data (representing a matrix of type `Isometrey3D`) and performs a series of transformations to produce a `quaternion`.
- @param poseArray: The array holding the pose information.
- @returns: A quaternion of the pose.

*getTranslation(poseArray)*:
- This function inputs an array of pose data (representing a matrix of type `Isometrey3D`) and performs a series of transformations to produce the transformation matrix associated with that pose data!
- @param poseArray: The array holding the pose information.
- @returns: A 3x1 matrix of the pose's xyz coordinates!

**private**:

*setIsometry(poseArray)*:
- This function takes an input of a static array of size 16 and transforms it into an pose of type `Isometry3D`!
- @param poseArray: the array holding the pose information.
- @returns: An Isometry3D representation of that pose!

### [float_standard](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_reach/xml_processing/parsing_lib/src/float_standard.cpp)

This contains a function that converts each floating point decimal to a nanometer (1 out of 10000000) scale! This is deemed nessesary to offset reach's use of full float for translating the quaternion into an `Isometry3D` and back- thus a nanometer was deemed a sufficent enough scale to round to!

*roundNano(number)*:
- This function rounds a double to seven decimal places!
- @param number: The number that will be rounded!
- @returns: The rounded number!

### [result_parser](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_reach/xml_processing/parsing_lib/src/result_parsing.cpp)

This class contains a function that will use threading to parse the information from the xml_parser file and returns an array of scores per `PoseArray`!

**public**:

*getScoreData(poseKeys, reachStudyMap, size)*:
- Runs a number of threads through the returned map of score data who assignthe returned score result to an associated index in the result array!
- @param poseKeys: A poseArray that will act as the keys for the data in the reachStudyMap
- @param reachStudyMap: A map that contains all of the data pulled from the reach_study in xml_parsing with the keys being of type pose and the results containing the return sucess and score!
- @returns: A vector containing all of the score data!

**private**:

*populateResults(start, end, max, poseKeys, reachStudyMap, results)*:
- Runs through the beginning and end indicies of a list adding the associated key values to a new "results" list!
- @param poseKeys: A poseArray that will act as the keys for the data in the reachStudyMap
- @param reachStudyMap: A map that contains all of the data pulled from the reach_study in xml_parsing with the keys being of type pose and the results containing the return sucess and score!
- @param results: An vector that contains all of the return scores indexed in the same manner as the poseKey results! (Non returnable since the same map needs to be populated without being overwritten! ^^)

*getKey(pose)*:
- Puts the pose data into the `poseData` (struct) format to be used as a key! For the map! :)
- @param pose: A pose that will act as the key in a data set in reachStudyMap once converted into a poseData struct!
- @returns: The pose data struct that contains the pose data and is able to be used as a key in the map!


### [xml_parser](https://github.com/natalieCloud/arp_reach/blob/feature/issue-24/top_level_launch/src/arp_resources/arp_reach/xml_processing/parsing_lib/src/xml_parser.cpp)

This class takes the results generated by the reach study done by the `ros-industrial` reach (Generated into an xml format) and parses the information into a vector of "ReachData" nodes. This parsing is done by leveraging the use of the `rapidxml` package!

**public**:

*parseXML(fname)*:
- This function takes the name of a file and parses it into a vector of data structs that contian a pose in space, and an associated `reachability score`!
- @param fname: The name of the file that the user passes in for the xml to read from.
- @returns: A vector of data structs containing the poseArray and the associated reach boolean and reach score!

*parseMap(fname)*:
- This function takes the name of a file and parses it into a vector of data structs that contian a pose in space, and an associated `reachability score`!
- @param fname: The name of the file that the user pases in for the xml to read from.
- @returns: A map containing key-value pairs of a Pose and its reach score results!

*MATRIX_SIZE*:
- The size of the pose matrix 
- global const int: 16

**private**:

*getItemCount(root_node)*:
- This function takes the root of a tree and traces through its children to obtain the number of child "item" nodes.
- @param root_node: The node at the root of the file!
- @returns The count of all of the item nodes!

*descendToItem(root_node)*:
- This function takes the root node of an xml tree and traces through its children to obtain the first instance of the child "item" node that contains thepose matrix and `reachability score` for that pose.
- @param root_node: The node at the root of the file!
- @returns: A pointer to the the first item child node!

*populatePoses(item_node, count)*:
 - This function creates a vector with populated `ReachData` structs!
 - @param item_node: The first child node in the xml tree.
 - @param count: The number of item child nodes in the xml tree.
 - @returns: A vector populated with filled ReachData nodes! 

*populatePoseMap(item_node, count)*:
- This function creates a map with populated `ReachData` structs.
- @param item_node: The first child node in the xml tree.
- @param count: The number of item child nodes in the xml tree.
- @returns: A map populated with filled ReachData key-value pairs 

*populateStruct(item_node, data)*:
- This function populates a pose struct with all the pose and `ReachData`!
- @param item_node: The first child node in the xml tree!
- @param data: A pointer to the struct that will contain the data!

*getPoseMatrix(item_node)*:
- Obtains the data from the xml tree (represented by an `Isometry3D` pose matrix) and represents the matrix in array format.
- @param item_node: The first child node in the xml tree!
- @returns: An array of Isometery3D data!

## Important Features!

A key part of this code, and something we had to offset with rounding (rather than dismantaling reach as a whole (as of right not at least- there is possible cause for that down the road) However as of right now reach runs the study - taking in a pose represented by a position (xyz) and qwuaternion (wxyz) and converts those data forms to type Isometry 3D! As a result, when reading the reach data and making the conversion back to the pose array position-quaternion form, the data- originally in Float64 form that goes out to 6-9 decimal plces, now goes out at least 16! As a result it was deemed nessesary to round down the results (In a sense of registering the keys and poses) to return the appropriate reach score per pose! This rounding occurs at two places:
1) array_transform - When the result data is added to the map it is done so with the rounded values rather than the ones calculated during conversion of isometry to quaternion!
2) result_parsing - When the poseArray data is getting passed to the map the values are rounded down to match the values of the keys!

Due to the original sizing of the pose and typical data in that range, it was deemed appropriate to round to a scale of 1/10000000 - or in practical (reality measurements) scale; A nanometer! Due to the nature of the points provided by and used by our path planning algorithm, it was deemed that this was an appropriate range to round to! 
